<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://s1.ax1x.com/2018/11/24/FFakY8.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://s1.ax1x.com/2018/11/24/FFakY8.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://s1.ax1x.com/2018/11/24/FFakY8.jpg">
  <link rel="mask-icon" href="https://s1.ax1x.com/2018/11/24/FFakY8.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.matthewdev.tech","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录Android面试中可能会遇到的面试题目和答案">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试笔记">
<meta property="og:url" content="https://blog.matthewdev.tech/2019/03/05/Android%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Matthew&#39;s Blog">
<meta property="og:description" content="记录Android面试中可能会遇到的面试题目和答案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gratisography.com/thumbnails/gratisography-black-white-suspension-bridge-thumbnail.jpg">
<meta property="article:published_time" content="2019-03-05T03:00:12.000Z">
<meta property="article:modified_time" content="2023-07-24T09:57:35.174Z">
<meta property="article:author" content="Matthew">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gratisography.com/thumbnails/gratisography-black-white-suspension-bridge-thumbnail.jpg">

<link rel="canonical" href="https://blog.matthewdev.tech/2019/03/05/Android%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android面试笔记 | Matthew's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Matthew's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.matthewdev.tech/2019/03/05/Android%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s1.ax1x.com/2018/11/24/FFakY8.jpg">
      <meta itemprop="name" content="Matthew">
      <meta itemprop="description" content="记录一下学习、工作笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matthew's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android面试笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-05 11:00:12" itemprop="dateCreated datePublished" datetime="2019-03-05T11:00:12+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-24 17:57:35" itemprop="dateModified" datetime="2023-07-24T17:57:35+08:00">2023-07-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://gratisography.com/thumbnails/gratisography-black-white-suspension-bridge-thumbnail.jpg" alt="封面"></p>
<blockquote>
<p>记录Android面试中可能会遇到的面试题目和答案</p>
</blockquote>
<span id="more"></span>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="Java中线程的创建方式"><a href="#Java中线程的创建方式" class="headerlink" title="Java中线程的创建方式"></a>Java中线程的创建方式</h4><p>Java中有三种创建线程的方式，或者说四种:</p>
<ol>
<li>继承Thread类实现多线程</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>通过线程池</li>
</ol>
<h4 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h4><p>线程池可以减少创建和销毁线程的次数，从而减少系统资源的消耗，当一个任务提交到线程池时：</p>
<ul>
<li>首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步</li>
<li>判断工作队列是否已满，没有满则加入工作队列，否则执行下一步</li>
<li>判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常</li>
</ul>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><blockquote>
<p>这篇博客讲解Handler非常详细：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8Ox_zAbgBwb3J0lAdE0gIw">Handler都没搞懂，拿什么去跳槽啊？！</a></p>
</blockquote>
<h4 id="Handler工作原理"><a href="#Handler工作原理" class="headerlink" title="Handler工作原理"></a>Handler工作原理</h4><p>Handler，Message，looper 和 MessageQueue 构成了安卓的消息机制，handler创建后可以通过 sendMessage 将消息加入消息队列，然后 looper不断的将消息从 MessageQueue 中取出来，回调到 Hander 的 handleMessage方法，从而实现线程的通信。</p>
<p>从两种情况来说，第一在UI线程创建Handler,此时我们不需要手动开启looper，因为在应用启动时，在ActivityThread的main方法中就创建了一个当前主线程的looper，并开启了消息队列，消息队列是一个无限循环，为什么无限循环不会ANR?因为可以说，应用的整个生命周期就是运行在这个消息循环中的，安卓是由事件驱动的，Looper.loop不断的接收处理事件，每一个点击触摸或者Activity每一个生命周期都是在Looper.loop的控制之下的，looper.loop一旦结束，应用程序的生命周期也就结束了。我们可以想想什么情况下会发生ANR，第一，事件没有得到处理，第二，事件正在处理，但是没有及时完成，而对事件进行处理的就是looper，所以只能说事件的处理如果阻塞会导致ANR，而不能说looper的无限循环会ANR。</p>
<p>另一种情况就是在子线程创建Handler,此时由于这个线程中没有默认开启的消息队列，所以我们需要手动调用looper.prepare(),并通过looper.loop开启消息</p>
<p>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存泄漏的场景和解决方案"><a href="#内存泄漏的场景和解决方案" class="headerlink" title="内存泄漏的场景和解决方案"></a>内存泄漏的场景和解决方案</h4><ol>
<li>非静态内部类的静态实例<br> 非静态内部类会持有外部类的引用，如果非静态内部类的实例是静态的，就会长期的维持着外部类的引用，组织被系统回收。 <ul>
<li>解决办法是：<br>  使用静态内部类</li>
</ul>
</li>
<li>多线程相关的匿名内部类和非静态内部类<br> 匿名内部类同样会持有外部类的引用，如果在线程中执行耗时操作就有可能发生内存泄漏，导致外部类无法被回收，直到耗时任务结束。<ul>
<li>解决办法是<br>  在页面退出时结束线程中的任务</li>
</ul>
</li>
<li>Handler内存泄漏<br> Handler导致的内存泄漏也可以被归纳为非静态内部类导致的，Handler内部message是被存储在MessageQueue中的，有些message不能马上被处理，存在的时间会很长，导致handler无法被回收，如果handler是非静态的，就会导致它的外部类无法被回收.<ul>
<li>解决办法是:<ul>
<li>使用静态handler，外部类引用使用弱引用处理</li>
<li>在退出页面时移除消息队列中的消息</li>
</ul>
</li>
</ul>
</li>
<li>Context导致内存泄漏<br> 单例模式是最常见的发生此泄漏的场景，比如传入一个Activity的Context被静态类引用，导致无法回收。<ul>
<li>解决办法是:<br>  根据场景确定使用Activity的Context还是Application的Context,因为二者生命周期不同，对于不必须使用Activity的Context的场景（Dialog）,一律采用Application的Context。</li>
</ul>
</li>
<li>静态View导致泄漏<br> 使用静态View可以避免每次启动Activity都去读取并渲染View，但是静态View会持有Activity的引用，导致无法回收。（View一旦被加载到界面中将会持有一个Context对象的引用，在这个例子中，这个context对象是我们的Activity，声明一个静态变量引用这个View，也就引用了activity）<ul>
<li>解决办法是<br>  在Activity销毁的时候将静态View设置为null</li>
</ul>
</li>
<li>WebView导致的内存泄漏<br> WebView只要使用一次，内存就不会被释放，所以WebView都存在内存泄漏的问题。<ul>
<li>通常的解决办法是<br>  为WebView单开一个进程，使用AIDL进行通信，根据业务需求在合适的时机释放掉</li>
</ul>
</li>
<li>资源对象未关闭导致<br> 如Cursor，File等，内部往往都使用了缓冲，会造成内存泄漏，一定要确保关闭它并将引用置为null。</li>
<li>集合中的对象未清理<br> 集合用于保存对象，如果集合越来越大，不进行合理的清理，尤其是如果集合是静态的。</li>
<li>Bitmap导致内存泄漏<br> Bitmap是比较占内存的，所以一定要在不使用的时候及时进行清理，避免静态变量持有大的Bitmap对象。</li>
<li>监听器未关闭<br>很多需要register和unregister的系统服务要在合适的时候进行unregister,手动添加的listener也需要及时移除。</li>
</ol>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><h4 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM?"></a>什么是OOM?</h4><p>程序申请内存过大，虚拟机无法满足我们，然后自杀了。这个现象通常出现在大图片的APP开发，或者需要用到很多图片的时候。通俗来讲就是我们的APP需要申请一块内存来存放图片的时候，系统认为我们的程序需要的内存过大，及时系统有充分的内存，比如1G，但是系统也不会分配给我们的APP，故而抛出OOM异常，程序没有捕捉异常，故而弹窗崩溃了.</p>
<h4 id="为什么有OOM"><a href="#为什么有OOM" class="headerlink" title="为什么有OOM?"></a>为什么有OOM?</h4><p>因为Android系统的APP每个进程或者虚拟机有最大内存限制，一旦超过这个限制系统就会抛出OOM错误。跟手机剩余内存是否充足没有多少关系。</p>
<h4 id="如何避免OOM"><a href="#如何避免OOM" class="headerlink" title="如何避免OOM?"></a>如何避免OOM?</h4><ol>
<li>使用更加轻量的数据结构：如使用ArrayMap&#x2F;SparseArray替代HashMap,HashMap更耗内存，因为它需要额外的实例对象来记录Mapping操作，SparseArray更加高效，因为它避免了Key Value的自动装箱，和装箱后的解箱操作。</li>
<li>减少枚举的使用，可以用静态常量或者注解@IntDef替代 </li>
<li>Bitmap优化:  <ul>
<li>尺寸压缩：通过InSampleSize设置合适的缩放</li>
<li>颜色质量：设置合适的format，ARGB_6666&#x2F;RBG_545&#x2F;ARGB_4444&#x2F;ALPHA_6，存在很大差异</li>
<li>inBitmap:使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小，但复用存在一些限制，具体体现在：在Android 4.4之前只能重用相同大小的Bitmap的内存，而Android 4.4及以后版本则只要后来的Bitmap比之前的小即可。使用inBitmap参数前，每创建一个Bitmap对象都会分配一块内存供其使用，而使用了inBitmap参数后，多个Bitmap可以复用一块内存，这样可以提高性能</li>
<li>简单通过SoftReference引用方式管理图片资源<br> 建一个SoftReference的hashmap，使用图片时，先检查这个hashmap是否有softreference，softreference的图片是否为空，如果为空将图片加载到softreference并加入haspmap。<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41ffbf31b20c">什么是OOM？如何解决OOM问题!</a></p>
</blockquote>
</li>
</ul>
</li>
<li>使用更小的图片 </li>
<li>StringBuilder替代String: 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</li>
<li>避免在类似onDraw这样的方法中创建对象，因为它会迅速占用大量内存，引起频繁的GC甚至内存抖动。</li>
<li>减少内存泄漏也是一种避免OOM的方法</li>
</ol>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><ul>
<li><strong>Standard 模式</strong>:<br>  Activity 可以有多个实例，每次启动 Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。</li>
<li><strong>SingleTop模式</strong>:<br>  当一个singleTop模式的Activity已经位于任务栈的栈顶，再去启动它时，不会再创建新的实例,如果不位于栈顶，就会创建新的实例。</li>
<li><strong>SingleTask模式</strong>:<br>  如果Activity已经位于栈顶，系统不会创建新的Activity实例，和singleTop模式一样。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶，并把它上面的activity出栈。   </li>
<li><strong>SingleInstance模式</strong>:<br>  singleInstance 模式也是单例的，但和singleTask不同，singleTask 只是任务栈内单例，系统里是可以有多个singleTask Activity实例的，而 singleInstance Activity 在整个系统里只有一个实例，启动一singleInstanceActivity 时，系统会创建一个新的任务栈，并且这个任务栈只有他一个Activity。</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>Activity生命周期方法的执行顺序为：<br>onCreate-&gt; onStart-&gt; onResume-&gt; onPause-&gt; onStop-&gt; onDestroy</p>
</blockquote>
<p>两个Activity跳转时生命周期方法的执行顺序为：</p>
<ol>
<li>启动A<br> onCreate - onStart -  onResume</li>
<li>在A中启动B<br> ActivityA  onPause<br> ActivityB  onCreate<br> ActivityB  onStart<br> ActivityB  onResume<br> ActivityA  onStop</li>
<li>从B中返回A（按物理硬件返回键）<br>ActivityB onPause<br>ActivityA onRestart<br>ActivityA onStart<br>ActivityA onResume<br>ActivityB onStop<br>ActivityB onDestroy</li>
<li>继续返回<br>ActivityA onPause<br>ActivityA onStop<br>ActivityA onDestroy</li>
</ol>
<h4 id="onRestart-的调用场景"><a href="#onRestart-的调用场景" class="headerlink" title="onRestart()的调用场景"></a>onRestart()的调用场景</h4><ol>
<li>按下home键之后，然后切换回来，会调用onRestart()。</li>
<li>从本Activity跳转到另一个Activity之后，按back键返回原来Activity，会调用onRestart()。</li>
<li>从本Activity切换到其他的应用，然后再从其他应用切换回来，会调用onRestart()。</li>
</ol>
<h4 id="Activity-的横竖屏的切换的生命周期，如何保存数据"><a href="#Activity-的横竖屏的切换的生命周期，如何保存数据" class="headerlink" title="Activity 的横竖屏的切换的生命周期，如何保存数据"></a>Activity 的横竖屏的切换的生命周期，如何保存数据</h4><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><h4 id="SurfaceView，它是什么？他的继承方式是什么？他与View的区别-从源码角度，如加载，绘制等-。"><a href="#SurfaceView，它是什么？他的继承方式是什么？他与View的区别-从源码角度，如加载，绘制等-。" class="headerlink" title="SurfaceView，它是什么？他的继承方式是什么？他与View的区别(从源码角度，如加载，绘制等)。"></a>SurfaceView，它是什么？他的继承方式是什么？他与View的区别(从源码角度，如加载，绘制等)。</h4><p>SurfaceView中采用了双缓冲机制，保证了UI界面的流畅性，同时 SurfaceView 不在主线程中绘制，而是另开辟一个线程去绘制，所以它不妨碍UI线程；</p>
<p>SurfaceView 继承于View，他和View主要有以下三点区别：</p>
<ol>
<li>View底层没有双缓冲机制，SurfaceView有</li>
<li>view主要适用于主动更新，而SurfaceView适用与被动的更新，如频繁的刷新</li>
<li>view会在主线程中去更新UI，而SurfaceView则在子线程中刷新</li>
</ol>
<p>SurfaceView的内容不在应用窗口上，所以不能使用变换（平移、缩放、旋转等）。也难以放在ListView或者ScrollView中，不能使用UI控件的一些特性比如View.setAlpha()。</p>
<p>View：显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等；必须在UI主线程内更新画面，速度较慢。</p>
<p>SurfaceView：基于view视图进行拓展的视图类，更适合2D游戏的开发；是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快，Camera预览界面使用SurfaceView。</p>
<p>GLSurfaceView：基于SurfaceView视图再次进行拓展的视图类，专用于3D游戏开发的视图；是SurfaceView的子类，openGL专用。</p>
<h3 id="设计模式和使用场景"><a href="#设计模式和使用场景" class="headerlink" title="设计模式和使用场景"></a>设计模式和使用场景</h3><ul>
<li>建造者模式：<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。使用场景比如最常见的AlertDialog,拿我们开发过程中举例，比如Camera开发过程中，可能需要设置一个初始化的相机配置，设置摄像头方向，闪光灯开闭，成像质量等等，这种场景下就可以使用建造者模式。</li>
<li>装饰者模式：<br>动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。装饰者模式可以在不改变原有类结构的情况下曾强类的功能，比如Java中的BufferedInputStream 包装FileInputStream，举个开发中的例子，比如在我们现有网络框架上需要增加新的功能，那么再包装一层即可，装饰者模式解决了继承存在的一些问题，比如多层继承代码的臃肿，使代码逻辑更清晰。</li>
<li>观察者模式：</li>
<li>代理模式：</li>
<li>门面模式：</li>
<li>单例模式：</li>
<li>生产者消费者模式：</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="如何实现进程保活"><a href="#如何实现进程保活" class="headerlink" title="如何实现进程保活"></a>如何实现进程保活</h4><ul>
<li>Service 设置成 START_STICKY kill 后会被重启(等待5秒左右)，重传Intent，保持与重启前一样</li>
<li>通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill</li>
<li>双进程Service： 让2个进程互相保护对方，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</li>
<li>用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响(Android5.0以上的版本不可行）联系厂商，加入白名单</li>
<li>锁屏状态下，开启一个一像素Activity</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="冷启动与热启动是什么，区别，如何优化，使用场景等"><a href="#冷启动与热启动是什么，区别，如何优化，使用场景等" class="headerlink" title="冷启动与热启动是什么，区别，如何优化，使用场景等"></a>冷启动与热启动是什么，区别，如何优化，使用场景等</h4><ul>
<li><p>冷启动：<br>当应用启动时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用， 这个启动方式就叫做冷启动（后台不存在该应用进程）。冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。</p>
</li>
<li><p>热启动：<br>当应用已经被打开， 但是被按下返回键、Home键等按键时回到桌面或者是其他程序的时候，再重新打开该app时， 这个方式叫做热启动（后台已经存在该应用进程）。热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application</p>
</li>
<li><p>冷启动的流程<br>当点击app的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate&#x2F;onStart&#x2F;onResume方法都走完了后最后才进行contentView的measure&#x2F;layout&#x2F;draw显示在界面上</p>
</li>
<li><p>冷启动的生命周期简要流程：<br>Application构造方法 –&gt; attachBaseContext()–&gt;onCreate –&gt;Activity构造方法 –&gt; onCreate() –&gt; 配置主体中的背景等操作 –&gt;onStart() –&gt; onResume() –&gt; 测量、布局、绘制显示</p>
</li>
<li><p>冷启动的优化：<br>主要是视觉上的优化，解决白屏问题，提高用户体验，所以通过上面冷启动的过程。能做的优化如下：</p>
<ul>
<li><p>减少 onCreate()方法的工作量</p>
</li>
<li><p>不要让 Application 参与业务的操作</p>
</li>
<li><p>不要在 Application 进行耗时操作</p>
</li>
<li><p>不要以静态变量的方式在 Application 保存数据</p>
</li>
<li><p>减少布局的复杂度和层级</p>
</li>
<li><p>减少主线程耗时</p>
</li>
</ul>
</li>
<li><p>为什么冷启动会有白屏黑屏问题？<br>原因在于加载主题样式Theme中的windowBackground等属性设置给MainActivity发生在inflate布局当onCreate&#x2F;onStart&#x2F;onResume方法之前，而windowBackground背景被设置成了白色或者黑色，所以我们进入app的第一个界面的时候会造成先白屏或黑屏一下再进入界面。<br>解决思路如下：</p>
<ol>
<li>给他设置 windowBackground 背景跟启动页的背景相同，如果你的启动页是张图片那么可以直接给 windowBackground 这个属性设置该图片那么就不会有一闪的效果了  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Splash_Theme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@android:style/Theme.NoTitleBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/splash_bg<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>    </span><br></pre></td></tr></table></figure></li>
<li>采用世面的处理方法，设置背景是透明的，给人一种延迟启动的感觉。,将背景颜色设置为透明色,这样当用户点击桌面APP图片的时候，并不会”立即”进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground 的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦）  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Splash_Theme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@android:style/Theme.NoTitleBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowIsTranslucent&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>以上两种方法是在视觉上显得更快，但其实只是一种表象，让应用启动的更快，有一种思路，将 Application 中的不必要的初始化动作实现懒加载，比如，在SpashActivity 显示后再发送消息到 Application，去初始化，这样可以将初始化的动作放在后边，缩短应用启动到用户看到界面的时间</li>
</ol>
</li>
</ul>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><blockquote>
<p>在Andorid上，系统会通过Activity Manager和Window Manager服务来监控应用的响应情况，如果应用响应超出限定时间了，为了避免对用户的体验造成困扰，系统就会弹出ANR提示供用户选择是否继续等待应用响应。</p>
</blockquote>
<h4 id="ANR的几种类型"><a href="#ANR的几种类型" class="headerlink" title="ANR的几种类型"></a>ANR的几种类型</h4><ul>
<li>主要类型：KeyDispatchTimeout(5 seconds)<blockquote>
<p>按键或触摸事件在特定时间(5秒)内无响应。</p>
</blockquote>
</li>
<li>小概率类型：BroadcastTimeout(10 seconds)<blockquote>
<p>BroadcastReceiver.onReceive()在特定时间(10秒)内无法处理完成。</p>
</blockquote>
</li>
<li>小概率类型：ServiceTimeout(20 seconds)<blockquote>
<p>Service各个生命周期函数在特定的时间(20秒)内无法处理完成。</p>
</blockquote>
</li>
</ul>
<h4 id="导致ANR的原因"><a href="#导致ANR的原因" class="headerlink" title="导致ANR的原因"></a>导致ANR的原因</h4><p>UI线程阻塞</p>
<ol>
<li>耗时的网络访问</li>
<li>大量的数据读写</li>
<li>数据库操作</li>
<li>硬件操作（比如camera)</li>
<li>调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候</li>
<li>service binder的数量达到上限</li>
<li>system server中发生WatchDog ANR</li>
<li>Service各个生命周期方法内进行和耗时操作，在20s内未处理完毕</li>
<li>其他线程持有锁，导致主线程等待超时</li>
<li>其它线程终止或崩溃导致主线程一直等待</li>
<li>BroadcastReceiver内进行了耗时操作，超过了10s的限制时间</li>
</ol>
<p>CPU满负荷工作时进行I&#x2F;O操作  </p>
<ul>
<li>当CPU使用率达到100%，在应用内仍在主线程上进行频繁的读写操作时，就会导致ANR的产生。</li>
</ul>
<p>内存不够用</p>
<ul>
<li>系统分配给每个App的可用内存是有限的，如果App内存在内存泄漏等情况的话，这个是会导致ANR的出现的。</li>
</ul>
<blockquote>
<p>只有主线程才会出现ANR</p>
</blockquote>
<h4 id="如何预防ANR"><a href="#如何预防ANR" class="headerlink" title="如何预防ANR"></a>如何预防ANR</h4><p>其实说来说去，导致ANR发生的罪魁祸首就是在主线程中进行了耗时操作，那么在常规情况下，我们可以通过以下几种方式来防止ANR的产生：</p>
<ul>
<li><p>主线程（UI线程）做耗时操作引发ANR预防</p>
<ul>
<li>不在主线程（UI）线程中做耗时操作，开辟单独的子线程来处理耗时阻塞事务</li>
<li>不在Service、BroadcastReceiver内做耗时操作</li>
<li>不乱用Thread的join()、sleep()、wait()方法</li>
</ul>
</li>
<li><p>CPU满负荷工作时进行I&#x2F;O操作情况下预防<br>  这种情况一般还是I&#x2F;O操作在主线程上进行导致的，同理可以通过开启子线程的方式解决。</p>
</li>
<li><p>内存不足产生的ANR<br>排查内存泄漏解决内存不够用的情况，推荐使用LeakCanary。</p>
</li>
</ul>
<h4 id="ANR排查"><a href="#ANR排查" class="headerlink" title="ANR排查"></a>ANR排查</h4><p>当发生ANR后，系统会在data&#x2F;anr&#x2F;目录下生成一个名为traces.txt的文件，文件内主要记录了ANR产生时系统信息的一些情况。通过分析此文件可以找出问题出现的位置、原因。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f720fef3cf0">【Android】应用ANR分析</a></p>
</blockquote>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="三级缓存原理"><a href="#三级缓存原理" class="headerlink" title="三级缓存原理"></a>三级缓存原理</h4><p>当 Android 端需要获得数据时比如获取网络中的图片，首先从内存中查找（按键查找），内存中没有的再从磁盘文件或sqlite中去查找，若磁盘中也没有才通过网络获取</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String-StringBuffer-StringBuilder区别"><a href="#String-StringBuffer-StringBuilder区别" class="headerlink" title="String,StringBuffer,StringBuilder区别"></a>String,StringBuffer,StringBuilder区别</h4><ul>
<li>String：适用于少量的字符串操作的情况</li>
<li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</li>
<li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况(线程安全)</li>
</ul>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><h4 id="Fragment与Fragment、Activity通信的四种方式"><a href="#Fragment与Fragment、Activity通信的四种方式" class="headerlink" title="Fragment与Fragment、Activity通信的四种方式"></a>Fragment与Fragment、Activity通信的四种方式</h4><ol>
<li>直接在一个Fragment中调用另一个Fragment的公开方法</li>
<li>通过接口调用</li>
<li>通过广播调用</li>
<li>直接调用Activity的公共方法</li>
</ol>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><h4 id="有序广播和无序广播"><a href="#有序广播和无序广播" class="headerlink" title="有序广播和无序广播"></a>有序广播和无序广播</h4><ul>
<li>有序广播<br>发送有序广播后，所有的接受者都可以接受，不可被拦截，不可被修改。</li>
<li>无序广播<br>发送无序广播，会根据优先级，一级一级向下传递，接受者可以修改广播内容，也可以终止广播事件。</li>
</ul>
<h4 id="Android广播的注册方式和区别"><a href="#Android广播的注册方式和区别" class="headerlink" title="Android广播的注册方式和区别"></a>Android广播的注册方式和区别</h4><ul>
<li>静态注册<br>静态注册可以成为常驻型广播，需要在Androidmanifest.xml文件中进行注册。这种注册方式不受页面生命周期的影响，即使退出页面，也可以接收到广播。此种注册为常驻型广播，会占用CPU资源。</li>
<li>动态注册<br>动态注册就是需要在代码中注册，这种注册方式也叫非常驻型广播，受生命周期影响，退出后就无法接受广播。这种注册方式需要解绑，否则会导致内存泄漏。</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote>
<p>Android中的对象有着4种引用类型，垃圾回收器对于不同的引用类型有着不同的处理方式，了解这些处理方式有助于我们避免写出会导致内存泄露的代码。</p>
</blockquote>
<ul>
<li><p>StrongReference（强引用）<br>强引用我们最常用的一种引用类型。当我们使用new关键字去新建一个对象的时候，创建的就是强引用。<br>当一个对象具有强引用，那么<strong>垃圾回收器是绝对不会的回收和销毁它的</strong>。对象的强引用可以在程序中到处传递。很多情况下，会同时有多个引用指向同一个对象。</p>
</li>
<li><p>WeakReference（弱引用）<br>弱引用通过类WeakReference来表示。弱引用并不能阻止垃圾回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。弱引用则没有这个问题。<strong>在垃圾回收器运行的时候，如果对一个对象的所有引用都是弱引用的话，该对象会被回收</strong>。</p>
</li>
<li><p>SoftReference（软引用）<br>我们可以把软引用理解成一种稍强的弱引用,使用类SoftReference来表示。<br>与弱引用的区别在于：<strong>如果一个对象只具有软引用，若内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，才会回收这些对象的内存</strong>。</p>
<blockquote>
<p>所以从引用的强度来讲： 强引用 &gt; 软引用 &gt; 弱引用。</p>
</blockquote>
</li>
<li><p>PhantomReference（虚引用）<br>一个只被虚引用持有的对象可能会在任何时候被GC回收。虚引用对对象的生存周期完全没有影响，也无法通过虚引用来获取对象实例，仅仅能在对象被回收时，得到一个系统通知（只能通过是否被加入到ReferenceQueue来判断是否被GC，这也是唯一判断对象是否被GC的途径）,所以<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<blockquote>
<p>这里参考了一篇博客，博主总结的很好：<a target="_blank" rel="noopener" href="http://allenfeng.com/2016/12/07/understanding-how-references-work-in-android-and-java/">理解Android中的引用类型</a></p>
</blockquote>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/461bf99964ec">2.2019Android高级面试题总结</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E6%80%BB%E7%BB%93/" rel="tag"># 总结</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/21/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" rel="prev" title="Git使用笔记">
      <i class="fa fa-chevron-left"></i> Git使用笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/08/GitHub%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" rel="next" title="GitHub静态博客绑定自定义域名">
      GitHub静态博客绑定自定义域名 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">Java中线程的创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">线程池的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler"><span class="nav-number">2.</span> <span class="nav-text">Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Handler%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">Handler工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.</span> <span class="nav-text">内存泄漏的场景和解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOM"><span class="nav-number">4.</span> <span class="nav-text">OOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOOM"><span class="nav-number">4.1.</span> <span class="nav-text">什么是OOM?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89OOM"><span class="nav-number">4.2.</span> <span class="nav-text">为什么有OOM?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOOM"><span class="nav-number">4.3.</span> <span class="nav-text">如何避免OOM?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity"><span class="nav-number">5.</span> <span class="nav-text">Activity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">启动模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.2.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onRestart-%E7%9A%84%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.</span> <span class="nav-text">onRestart()的调用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-%E7%9A%84%E6%A8%AA%E7%AB%96%E5%B1%8F%E7%9A%84%E5%88%87%E6%8D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.</span> <span class="nav-text">Activity 的横竖屏的切换的生命周期，如何保存数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View"><span class="nav-number">6.</span> <span class="nav-text">View</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SurfaceView%EF%BC%8C%E5%AE%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E4%B8%8EView%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%EF%BC%8C%E5%A6%82%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%98%E5%88%B6%E7%AD%89-%E3%80%82"><span class="nav-number">6.1.</span> <span class="nav-text">SurfaceView，它是什么？他的继承方式是什么？他与View的区别(从源码角度，如加载，绘制等)。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.</span> <span class="nav-text">设计模式和使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="nav-number">8.1.</span> <span class="nav-text">如何实现进程保活</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%83%AD%E5%90%AF%E5%8A%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89"><span class="nav-number">9.1.</span> <span class="nav-text">冷启动与热启动是什么，区别，如何优化，使用场景等</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANR"><span class="nav-number">10.</span> <span class="nav-text">ANR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ANR%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">ANR的几种类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E8%87%B4ANR%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">10.2.</span> <span class="nav-text">导致ANR的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2ANR"><span class="nav-number">10.3.</span> <span class="nav-text">如何预防ANR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ANR%E6%8E%92%E6%9F%A5"><span class="nav-number">10.4.</span> <span class="nav-text">ANR排查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">11.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86"><span class="nav-number">11.1.</span> <span class="nav-text">三级缓存原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">12.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String-StringBuffer-StringBuilder%E5%8C%BA%E5%88%AB"><span class="nav-number">12.1.</span> <span class="nav-text">String,StringBuffer,StringBuilder区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragment"><span class="nav-number">13.</span> <span class="nav-text">Fragment</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fragment%E4%B8%8EFragment%E3%80%81Activity%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">13.1.</span> <span class="nav-text">Fragment与Fragment、Activity通信的四种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">14.</span> <span class="nav-text">广播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD%E5%92%8C%E6%97%A0%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="nav-number">14.1.</span> <span class="nav-text">有序广播和无序广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android%E5%B9%BF%E6%92%AD%E7%9A%84%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.</span> <span class="nav-text">Android广播的注册方式和区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">16.</span> <span class="nav-text">引用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Matthew"
      src="https://s1.ax1x.com/2018/11/24/FFakY8.jpg">
  <p class="site-author-name" itemprop="name">Matthew</p>
  <div class="site-description" itemprop="description">记录一下学习、工作笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MatthewDevelop" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MatthewDevelop" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:guocheng0816@163.com" title="E-Mail → mailto:guocheng0816@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://llcat.tech/" title="http:&#x2F;&#x2F;llcat.tech" rel="noopener" target="_blank">llcat</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://jarh.tech/" title="https:&#x2F;&#x2F;jarh.tech&#x2F;" rel="noopener" target="_blank">rh</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Matthew</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">38k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">34 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
